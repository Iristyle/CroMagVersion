<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Xml" #>
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
//DANGER WILL ROBINSON - TOOL GENERATED FILE - DO NOT MODIFY THIS FILE BY HAND!
//USE THE SOLUTIONS VERSION.PROPS TO TWEAK MINOR / MAJOR VERSIONS
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
using System;
using System.Reflection;
using System.Resources;
<# WriteAttributes(); #>
<#+

private string drive = Environment.GetEnvironmentVariable("SystemDrive");

private void WriteAttributes()
{
  var localPath = Path.GetDirectoryName(Host.TemplateFile);

  string SolutionDir = Path.Combine(localPath, "..\\..\\.."), //VS default
    Configuration = "Unspecified";

  //extra space at end is HACK to prevent a trailing \" which eats the \
  try
  {
    SolutionDir = Host.ResolveParameterValue("", "", "SolutionDir");
    SolutionDir = SolutionDir.Remove(SolutionDir.Length - 1, 1);
  } catch { }
  try
  {
    Configuration = Host.ResolveParameterValue("", "", "Configuration");
    Configuration = Configuration.Remove(Configuration.Length - 1, 1);
  }
  catch {
#>
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// Generated by Run Custom Tool within Visual Studio
// This output is temporary and may have incorrect information
// It will be regenerated during normal build process
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
<#+
     }

  XmlDocument doc = new XmlDocument();
  doc.Load(Path.Combine(SolutionDir, "version.props"));
  var root = doc.SelectSingleNode("VersioningScheme");

  Dictionary<string, string> validTokens = new Dictionary<string, string>()
  {
    //typically set by build server, will end up being, in this order:
    //  - Override BUILD_NUMBER specified in version.props if present
    //  - BUILD_NUMBER env variable as specified by a build server like Jenkins
    //  - 0 if not specified
  { "MajorVersion", GetDefaultVersion(root).Major.ToString() },
    { "MinorVersion", GetDefaultVersion(root).Minor.ToString() },
    { "BuildVersion", GetDefaultVersion(root).Build.ToString() },
    { "RevisionVersion", GetDefaultVersion(root).Revision.ToString() },
    { "Configuration", Configuration },
    { "Changeset", GitVersion(localPath) ?? HgVersion(localPath) ?? string.Empty },
    { "YearMonth", DateTime.UtcNow.ToString("yyMM") },
    { "DayNumber", DateTime.UtcNow.ToString("dd") },
    { "Year", DateTime.UtcNow.ToString("yyyy") },
    //mandatory

    { "VersionCompany", GetNode(root, "VersionCompany/text()", true) },
    { "VersionCompanyUrl", GetNode(root, "VersionCompanyUrl/text()", true) },
  };

  //variables defined for consumption
  //each segment is limited to 65536, so cook craftily
  validTokens.Add("VersionNumber", string.Format("{0}.{1}.{2}.{3}",
    validTokens["MajorVersion"], validTokens["MinorVersion"],
    validTokens["BuildVersion"], validTokens["RevisionVersion"]));

  var assemblyCompanyLayout = GetNode(root, "AssemblyCompanyLayout/text()", false) ?? string.Empty;
  var assemblyCopyrightLayout = GetNode(root, "AssemblyCopyrightLayout/text()", false) ?? string.Empty;
  var assemblyConfigurationLayout = GetNode(root, "AssemblyConfigurationLayout/text()", false) ?? string.Empty;
  var assemblyVersionLayout = GetNode(root, "AssemblyVersionLayout/text()", false) ?? string.Empty;
  var assemblyFileVersionLayout = GetNode(root, "AssemblyFileVersionLayout/text()", false) ?? string.Empty;
  var assemblyInformationalVersionLayout = GetNode(root, "AssemblyInformationalVersionLayout/text()", false) ?? string.Empty;

  // search replace msbuild style tokens that a user might incorporate
  if (!string.IsNullOrEmpty(assemblyCompanyLayout))
  {
    assemblyCompanyLayout = ReplaceTokens(assemblyCompanyLayout, validTokens).Trim();
  }

  if (!string.IsNullOrEmpty(assemblyCopyrightLayout))
  {
    assemblyCopyrightLayout = ReplaceTokens(assemblyCopyrightLayout, validTokens).Trim();
  }

  if (!string.IsNullOrEmpty(assemblyConfigurationLayout))
  {
    assemblyConfigurationLayout = ReplaceTokens(assemblyConfigurationLayout, validTokens).Trim();
  }

  if (!string.IsNullOrEmpty(assemblyVersionLayout) && assemblyVersionLayout != validTokens["VersionNumber"])
  {
    assemblyVersionLayout = ReplaceTokens(assemblyVersionLayout, validTokens).Trim();
  }

  if (!string.IsNullOrEmpty(assemblyFileVersionLayout) && assemblyFileVersionLayout != validTokens["VersionNumber"])
  {
    assemblyFileVersionLayout = ReplaceTokens(assemblyFileVersionLayout, validTokens).Trim();
  }

  if (!string.IsNullOrEmpty(assemblyInformationalVersionLayout) && assemblyInformationalVersionLayout != validTokens["VersionNumber"])
  {
    assemblyInformationalVersionLayout = ReplaceTokens(assemblyInformationalVersionLayout, validTokens).Trim();
  }
#>

<#+ if (Configuration == "Unspecified") { #>

<#+ } #>

<#+ if (!string.IsNullOrEmpty(assemblyCompanyLayout)) { #>
[assembly: AssemblyCompany("<#= assemblyCompanyLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyCopyrightLayout)) { #>
[assembly: AssemblyCopyright("<#= assemblyCopyrightLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyConfigurationLayout)) { #>
[assembly: AssemblyConfiguration("<#= assemblyConfigurationLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyVersionLayout)) { #>
[assembly: AssemblyVersion("<#= assemblyVersionLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyFileVersionLayout)) { #>
[assembly: AssemblyFileVersion("<#= assemblyFileVersionLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyInformationalVersionLayout)) { #>
[assembly: AssemblyInformationalVersion("<#= assemblyInformationalVersionLayout #>")]
<#+ } #>
<#+

//TODO: find a way to include other stuff in version.props for the shared asm info
//[assembly: AssemblyTrademark("" "")]
//[assembly: CLSCompliant(true)]
//[assembly: NeutralResourcesLanguage("en")]
//[assembly: CodeLanguage("CS")]

}

    private Version GetDefaultVersion(XmlNode root)
    {
        var major = Int32.MinValue;
        var minor = Int32.MinValue;
        var build = Int32.MinValue;
    var revision = Int32.MinValue;

        var majorFromConvention = GetNode(root, "MajorVersion/text()", false);
        int.TryParse(majorFromConvention, out major);

    var minorFromConvention = GetNode(root, "MinorVersion/text()", false);
    int.TryParse(minorFromConvention, out minor);

        var buildNumberFromEnvironment = Environment.GetEnvironmentVariable("BUILD_NUMBER");
        if (!string.IsNullOrEmpty(buildNumberFromEnvironment))
        {
            if (buildNumberFromEnvironment.Contains("."))
            {
                Version buildNumberFromEnvironmentVersion = null;
                if (Version.TryParse(buildNumberFromEnvironment, out buildNumberFromEnvironmentVersion))
                {
                    if (major == Int32.MinValue)
                    {
                        major = buildNumberFromEnvironmentVersion.Major;
                    }

                    if (minor == Int32.MinValue)
                    {
                        minor = buildNumberFromEnvironmentVersion.Minor;
                    }

                    if (build == Int32.MinValue)
                    {
                        build = buildNumberFromEnvironmentVersion.Build;
                    }

                    if (revision == Int32.MinValue)
                    {
                        revision = buildNumberFromEnvironmentVersion.Revision;
                    }
                }
            }
            else
            {
                if (build == Int32.MinValue)
                {
                    int.TryParse(buildNumberFromEnvironment, out build);
                }
            }
        }

        var buildNumberFromConvention = GetNode(root, "BUILD_NUMBER/text()", false);
        if (!string.IsNullOrEmpty(buildNumberFromConvention))
        {
            if (buildNumberFromConvention.Contains("."))
            {
                Version buildNumberFromConventionVersion = null;

                if (Version.TryParse(buildNumberFromConvention, out buildNumberFromConventionVersion))
                {
                    if (major == Int32.MinValue)
                    {
                        major = buildNumberFromConventionVersion.Major;
                    }

                    if (minor == Int32.MinValue)
                    {
                        minor = buildNumberFromConventionVersion.Minor;
                    }

                    if (build == Int32.MinValue)
                    {
                        build = buildNumberFromConventionVersion.Build;
                    }

                    if (revision == Int32.MinValue)
                    {
                        revision = buildNumberFromConventionVersion.Revision;
                    }
                }
            }
            else
            {
                if (build == Int32.MinValue)
                {
                    int.TryParse(buildNumberFromConvention, out build);
                }
            }
        }

        if (major == Int32.MinValue)
        {
            major = 1;
        }

    if (minor == Int32.MinValue)
    {
      minor = 0;
    }

    if (build == Int32.MinValue)
    {
        var epochDateTime = new DateTime(2000, 1, 1);
      build = DateTime.UtcNow.Subtract(epochDateTime).Days;
    }

    if (revision == Int32.MinValue)
    {
        revision = (int)DateTime.UtcNow.TimeOfDay.TotalSeconds;
    }

        var version = new Version(major, minor, build, revision);
        return version;
    }

  private string GetNode(XmlNode node, string xpath, bool @throw)
  {
    var child = node.SelectSingleNode(xpath);
    if (child != null) { return child.Value; }

    if (!@throw) { return null; }
    string name = xpath.Replace("/text()", "");
    throw new ArgumentException(name + " must be specified in version.props",
      name);
  }

  private string ReplaceTokens(string source, Dictionary<string,string> tokens)
  {
    foreach (string token in tokens.Keys)
    {
      source = source.Replace("$(" + token + ")", tokens[token]);
    }

    return source;
  }

  private string GetProcessOutput(string localPath, string path, string command)
  {
    if (!File.Exists(path)) { return null; }

    var psi = new ProcessStartInfo(path, command)
    {
      WindowStyle = ProcessWindowStyle.Hidden,
      UseShellExecute = false,
      ErrorDialog = false,
      CreateNoWindow = false,
      WorkingDirectory = localPath,
      RedirectStandardOutput = true,
      RedirectStandardError = true
    };

    using (var p = Process.Start(psi))
    {
      p.WaitForExit();
      if (p.ExitCode != 0)
      {
        using (var standardError = p.StandardError)
        {
          //TODO: just write to stdout?
          //Host.Error(standardError.ReadToEnd());
        }
        return null;
      }

      using (var standardOutput = p.StandardOutput)
      {
        return standardOutput.ReadToEnd();
      }
    }
  }

  public string HgVersion(string path)
  {
    path = path ?? ".";

    //Log.LogMessage(MessageImportance.Low, "path is {0}", path);
    var programFiles = string.Format(@"{0}\Program Files", drive);
    var programFilesx86 = string.Format(@"{0}\Program Files (x86)", drive);
    var hg = string.Format(@"{0}\TortoiseHg\hg.exe", programFiles);
    var hgx86 = string.Format(@"{0}\TortoiseHg\hg.exe", programFilesx86);
    var merc = string.Format(@"{0}\Mercurial\hg.exe", programFiles);
    var mercx86 = string.Format(@"{0}\Mercurial\hg.exe", programFilesx86);

    //try standard locations and fall back to assumption of it being in path
    var hgPath = File.Exists(hgx86) ? hgx86 : File.Exists(hg) ? hg :
      File.Exists(mercx86) ? mercx86 : File.Exists(merc)? merc : null;

    if (null == hgPath)
    {
      foreach (string p in Environment.GetEnvironmentVariable("PATH").Split(';'))
      {
        var test = Path.Combine(p, "hg.exe");
        if (File.Exists(test))
        {
          hgPath = test;
          break;
        }
      }
    }

    return GetProcessOutput(path, hgPath, "log -l 1 --template \"{node|short}\"");
  }

  //borrowed / modified from from https://gist.github.com/966148
  public string GitVersion(string path)
  {
    path = path ?? ".";

    //Log.LogMessage(MessageImportance.Low, "path is {0}", path);
    var programFiles = string.Format(@"{0}\Program Files", drive);
    var programFilesx86 = string.Format(@"{0}\Program Files (x86)", drive);
    var git = string.Format(@"{0}\git\bin\git.exe", programFiles);
    var gitx86 = string.Format(@"{0}\git\bin\git.exe", programFilesx86);

    //try standard locations and fall back to assumption of it being in path
    var gitPath = File.Exists(gitx86) ? gitx86 : File.Exists(git) ? git : null;

    if (null == gitPath)
    {
      foreach (string p in Environment.GetEnvironmentVariable("PATH").Split(';'))
      {
        var test = Path.Combine(p, "git.exe");
        if (File.Exists(test))
        {
          gitPath = test;
          break;
        }
      }
    }

    return GetProcessOutput(path, gitPath, "log -1 --pretty=format:%h");
  }
#>
