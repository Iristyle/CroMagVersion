<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Xml" #>
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
//DANGER WILL ROBINSON - TOOL GENERATED FILE - DO NOT MODIFY THIS FILE BY HAND!
//USE THE SOLUTIONS VERSION.PROPS TO TWEAK MINOR / MAJOR VERSIONS
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
using System;
using System.Reflection;
using System.Resources;
<# WriteAttributes(); #>
<#+

private string drive = Environment.GetEnvironmentVariable("SystemDrive");

private void WriteAttributes()
{
  var localPath = Path.GetDirectoryName(Host.TemplateFile);

  string SolutionDir = Path.Combine(localPath, "..\\..\\.."), //VS default
    Configuration = "Unspecified";

  //extra space at end is HACK to prevent a trailing \" which eats the \
  try
  {
    SolutionDir = Host.ResolveParameterValue("", "", "SolutionDir");
    SolutionDir = SolutionDir.Remove(SolutionDir.Length - 1, 1);
  } catch { }
  try
  {
    Configuration = Host.ResolveParameterValue("", "", "Configuration");
    Configuration = Configuration.Remove(Configuration.Length - 1, 1);
  }
  catch {
#>
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// Generated by Run Custom Tool within Visual Studio
// This output is temporary and may have incorrect information
// It will be regenerated during normal build process
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
<#+
     }

  XmlDocument doc = new XmlDocument();
  doc.Load(Path.Combine(SolutionDir, "version.props"));
  var root = doc.SelectSingleNode("VersioningScheme");

  Dictionary<string, string> validTokens = new Dictionary<string, string>()
  {
    //typically set by build server, will end up being, in this order:
    //  - Override BUILD_NUMBER specified in version.props if present
    //  - BUILD_NUMBER env variable as specified by a build server like Jenkins
    //  - 0 if not specified
    { "Build", MaxLength(GetNode(root, "BUILD_NUMBER/text()", false)
      //use only up to the last 3 characters so we don't overrun 65536
      ?? Environment.GetEnvironmentVariable("BUILD_NUMBER") ?? "0", 3) },
    { "Revision", "0" },
    { "Configuration", Configuration },
    { "Changeset", GitVersion(localPath) ?? HgVersion(localPath) ?? string.Empty },
	{ "Branch", GitBranch(localPath) ?? string.Empty },
    { "YearMonth", DateTime.UtcNow.ToString("yyMM") },
    { "DayNumber", DateTime.UtcNow.ToString("dd") },
    { "Year", DateTime.UtcNow.ToString("yyyy") },
    //mandatory
    { "MajorVersion", GetNode(root, "MajorVersion/text()", true) },
    { "MinorVersion", GetNode(root, "MinorVersion/text()", true) },
	{ "PatchVersion", GetNode(root, "PatchVersion/text()", false) },
    { "VersionCompany", GetNode(root, "VersionCompany/text()", true) },
    { "VersionCompanyUrl", GetNode(root, "VersionCompanyUrl/text()", true) },
	{ "VERSION_SUFFIX", Environment.GetEnvironmentVariable("VERSION_SUFFIX") ?? string.Empty },
  };

  //variables defined for consumption
  //each segment is limited to 65536, so cook craftily
  validTokens.Add("BuildVersion", validTokens["YearMonth"]);
  validTokens.Add("RevisionVersion", validTokens["DayNumber"] +
    validTokens["Build"]);
  validTokens.Add("VersionNumber", string.Format("{0}.{1}.{2}.{3}",
    validTokens["MajorVersion"], validTokens["MinorVersion"],
    validTokens["BuildVersion"], validTokens["RevisionVersion"]));

  string AssemblyFileVersionLayout =
    GetNode(root, "AssemblyFileVersionLayout/text()", false)
    ?? validTokens["VersionNumber"],
  AssemblyInformationalVersionLayout =
    GetNode(root, "AssemblyInformationalVersionLayout/text()", false)
    ?? validTokens["VersionNumber"];

  // search replace msbuild style tokens that a user might incorporate
  if (AssemblyFileVersionLayout != validTokens["VersionNumber"])
  {
    AssemblyFileVersionLayout = ReplaceTokens(AssemblyFileVersionLayout, validTokens)
      .Trim();
  }
  if (AssemblyInformationalVersionLayout != validTokens["VersionNumber"])
  {
    AssemblyInformationalVersionLayout =
      ReplaceTokens(AssemblyInformationalVersionLayout, validTokens).Trim();
  }
#>

<#+ if (Configuration == "Unspecified") { #>

<#+ } #>

[assembly: AssemblyCompany("<#= validTokens["VersionCompany"] #> <#= validTokens["VersionCompanyUrl"] #>")]
[assembly: AssemblyCopyright("Copyright © <#= validTokens["Year"] #> <#= validTokens["VersionCompany"] #>")]
[assembly: AssemblyConfiguration("<#= validTokens["Branch"] #>-<#= validTokens["Changeset"] #>")]
[assembly: AssemblyVersion("<#= validTokens["VersionNumber"] #>")]
[assembly: AssemblyFileVersion("<#= AssemblyFileVersionLayout.Trim() #>")]
[assembly: AssemblyInformationalVersion("<#= AssemblyInformationalVersionLayout.Trim() #>")]
<#+

//TODO: find a way to include other stuff in version.props for the shared asm info
//[assembly: AssemblyTrademark("" "")]
//[assembly: CLSCompliant(true)]
//[assembly: NeutralResourcesLanguage("en")]
//[assembly: CodeLanguage("CS")]

}

  private string MaxLength(string s, int length)
  {
    if (s.Length > 3) { return s.Substring(s.Length - 3); }
    return s;
  }

  private string GetNode(XmlNode node, string xpath, bool @throw)
  {
    var child = node.SelectSingleNode(xpath);
    if (child != null) { return child.Value; }

    if (!@throw) { return null; }
    string name = xpath.Replace("/text()", "");
    throw new ArgumentException(name + " must be specified in version.props",
      name);
  }

  private string ReplaceTokens(string source, Dictionary<string,string> tokens)
  {
    foreach (string token in tokens.Keys)
    {
      source = source.Replace("$(" + token + ")", tokens[token]);
    }

    return source;
  }

  private string GetProcessOutput(string localPath, string path, string command)
  {
    if (!File.Exists(path)) { return null; }

    var psi = new ProcessStartInfo(path, command)
    {
      WindowStyle = ProcessWindowStyle.Hidden,
      UseShellExecute = false,
      ErrorDialog = false,
      CreateNoWindow = false,
      WorkingDirectory = localPath,
      RedirectStandardOutput = true,
      RedirectStandardError = true
    };

    using (var p = Process.Start(psi))
    {
      p.WaitForExit();
      if (p.ExitCode != 0)
      {
        using (var standardError = p.StandardError)
        {
          //TODO: just write to stdout?
          //Host.Error(standardError.ReadToEnd());
        }
        return null;
      }

      using (var standardOutput = p.StandardOutput)
      {
        return standardOutput.ReadToEnd();
      }
    }
  }

  public string HgVersion(string path)
  {
    path = path ?? ".";

    //Log.LogMessage(MessageImportance.Low, "path is {0}", path);
    var programFiles = string.Format(@"{0}\Program Files", drive);
    var programFilesx86 = string.Format(@"{0}\Program Files (x86)", drive);
    var hg = string.Format(@"{0}\TortoiseHg\hg.exe", programFiles);
    var hgx86 = string.Format(@"{0}\TortoiseHg\hg.exe", programFilesx86);
    var merc = string.Format(@"{0}\Mercurial\hg.exe", programFiles);
    var mercx86 = string.Format(@"{0}\Mercurial\hg.exe", programFilesx86);

    //try standard locations and fall back to assumption of it being in path
    var hgPath = File.Exists(hgx86) ? hgx86 : File.Exists(hg) ? hg :
      File.Exists(mercx86) ? mercx86 : File.Exists(merc)? merc : null;

    if (null == hgPath)
    {
      foreach (string p in Environment.GetEnvironmentVariable("PATH").Split(';'))
      {
        var test = Path.Combine(p, "hg.exe");
        if (File.Exists(test))
        {
          hgPath = test;
          break;
        }
      }
    }

    return GetProcessOutput(path, hgPath, "log -l 1 --template \"{node|short}\"");
  }

  //borrowed / modified from from https://gist.github.com/966148
  public string GitVersion(string path)
  {
    path = path ?? ".";

    //Log.LogMessage(MessageImportance.Low, "path is {0}", path);
    var programFiles = string.Format(@"{0}\Program Files", drive);
    var programFilesx86 = string.Format(@"{0}\Program Files (x86)", drive);
    var git = string.Format(@"{0}\git\bin\git.exe", programFiles);
    var gitx86 = string.Format(@"{0}\git\bin\git.exe", programFilesx86);

    //try standard locations and fall back to assumption of it being in path
    var gitPath = File.Exists(gitx86) ? gitx86 : File.Exists(git) ? git : null;

    if (null == gitPath)
    {
      foreach (string p in Environment.GetEnvironmentVariable("PATH").Split(';'))
      {
        var test = Path.Combine(p, "git.exe");
        if (File.Exists(test))
        {
          gitPath = test;
          break;
        }
      }
    }

    return GetProcessOutput(path, gitPath, "log -1 --pretty=format:%h");
  }
  
  public string GitBranch(string path)
  {
    path = path ?? ".";

    //Log.LogMessage(MessageImportance.Low, "path is {0}", path);
    var programFiles = string.Format(@"{0}\Program Files", drive);
    var programFilesx86 = string.Format(@"{0}\Program Files (x86)", drive);
    var git = string.Format(@"{0}\git\bin\git.exe", programFiles);
    var gitx86 = string.Format(@"{0}\git\bin\git.exe", programFilesx86);

    //try standard locations and fall back to assumption of it being in path
    var gitPath = File.Exists(gitx86) ? gitx86 : File.Exists(git) ? git : null;

    if (null == gitPath)
    {
      foreach (string p in Environment.GetEnvironmentVariable("PATH").Split(';'))
      {
        var test = Path.Combine(p, "git.exe");
        if (File.Exists(test))
        {
          gitPath = test;
          break;
        }
      }
    }

    return GetProcessOutput(path, gitPath, "rev-parse --abbrev-ref HEAD").Replace("\n",string.Empty).Replace("\r",string.Empty);
  }
#>
