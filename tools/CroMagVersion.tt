<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Xml" #>
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
//DANGER WILL ROBINSON - TOOL GENERATED FILE - DO NOT MODIFY THIS FILE BY HAND!
//USE THE SOLUTIONS VERSION.PROPS OR PROJECTS VERSION.PROPS 
//TO TWEAK MINOR / MAJOR VERSIONS
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
using System;
using System.Reflection;
using System.Resources;
<# WriteAttributes(); #>
<#+

private string drive = Environment.GetEnvironmentVariable("SystemDrive");

private void WriteAttributes()
{
	var localPath = Path.GetDirectoryName(Host.TemplateFile);
    var SolutionDir = Path.Combine(localPath, "..\\..\\.."); //VS default
    var ProjectDir = Path.Combine(localPath, "..\\.."); //VS default
	var Configuration = "Unspecified";

	//extra space at end is HACK to prevent a trailing \" which eats the \
	try
	{
		SolutionDir = Host.ResolveAssemblyReference("$(SolutionDir)");
		SolutionDir = SolutionDir.Remove(SolutionDir.Length - 1, 1);
	} catch { }

	try
	{
	    ProjectDir = Host.ResolveAssemblyReference("$(ProjectDir)");
		ProjectDir = ProjectDir.Remove(ProjectDir.Length - 1, 1);		
	} catch { }

	try
	{
		Configuration = Host.ResolveParameterValue("", "", "Configuration");
		Configuration = Configuration.Remove(Configuration.Length - 1, 1);
	}
	catch {
#>
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// Generated by Run Custom Tool within Visual Studio
// This output is temporary and may have incorrect information
// It will be regenerated during normal build process
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
<#+
    }

	var projectVersionPropsPath = Path.Combine(ProjectDir, "version.props");
    var projectVersionPropsXmlDocument = new XmlDocument();
    XmlNode projectRoot = null;
    if (File.Exists(projectVersionPropsPath))
    {
        projectVersionPropsXmlDocument.Load(projectVersionPropsPath);
		projectRoot = projectVersionPropsXmlDocument.SelectSingleNode("VersioningScheme");
    }

	var solutionVersionPropsPath = Path.Combine(SolutionDir, "version.props");
	var solutionVersionPropsXmlDocument = new XmlDocument();
    solutionVersionPropsXmlDocument.Load(solutionVersionPropsPath);
	var solutionRoot = solutionVersionPropsXmlDocument.SelectSingleNode("VersioningScheme");

	var validTokens = new Dictionary<string, string>()
	{
		//typically set by build server, will end up being, in this order:
		//  - Override BUILD_NUMBER specified in version.props if present
		//  - BUILD_NUMBER env variable as specified by a build server like Jenkins
		//  - 0 if not specified
		{ "MajorVersion", GetDefaultVersion(projectRoot, solutionRoot).Major.ToString() },
		{ "MinorVersion", GetDefaultVersion(projectRoot, solutionRoot).Minor.ToString() },
		{ "BuildVersion", GetDefaultVersion(projectRoot, solutionRoot).Build.ToString() },
		{ "RevisionVersion", GetDefaultVersion(projectRoot, solutionRoot).Revision.ToString() },
		{ "Configuration", Configuration },
		{ "Changeset", GitVersion(localPath) ?? HgVersion(localPath) ?? string.Empty },
		{ "YearMonth", DateTime.UtcNow.ToString("yyMM") },
		{ "DayNumber", DateTime.UtcNow.ToString("dd") },
		{ "Year", DateTime.UtcNow.ToString("yyyy") },
		//mandatory

		{ "VersionCompany", GetNode(projectRoot, solutionRoot, "VersionCompany/text()", true) },
		{ "VersionCompanyUrl", GetNode(projectRoot, solutionRoot, "VersionCompanyUrl/text()", true) },
	};

	//variables defined for consumption
	//each segment is limited to 65536, so cook craftily
	validTokens.Add("VersionNumber", string.Format("{0}.{1}.{2}.{3}",
	validTokens["MajorVersion"], validTokens["MinorVersion"],
	validTokens["BuildVersion"], validTokens["RevisionVersion"]));

	var assemblyCompanyLayout = GetNode(projectRoot, solutionRoot, "AssemblyCompanyLayout/text()", false) ?? string.Empty;
	var assemblyCopyrightLayout = GetNode(projectRoot, solutionRoot, "AssemblyCopyrightLayout/text()", false) ?? string.Empty;
	var assemblyConfigurationLayout = GetNode(projectRoot, solutionRoot, "AssemblyConfigurationLayout/text()", false) ?? string.Empty;
	var assemblyVersionLayout = GetNode(projectRoot, solutionRoot, "AssemblyVersionLayout/text()", false) ?? string.Empty;
	var assemblyFileVersionLayout = GetNode(projectRoot, solutionRoot, "AssemblyFileVersionLayout/text()", false) ?? string.Empty;
	var assemblyInformationalVersionLayout = GetNode(projectRoot, solutionRoot, "AssemblyInformationalVersionLayout/text()", false) ?? string.Empty;

	// search replace msbuild style tokens that a user might incorporate
	if (!string.IsNullOrEmpty(assemblyCompanyLayout))
	{
		assemblyCompanyLayout = ReplaceTokens(assemblyCompanyLayout, validTokens).Trim();
	}

	if (!string.IsNullOrEmpty(assemblyCopyrightLayout))
	{
		assemblyCopyrightLayout = ReplaceTokens(assemblyCopyrightLayout, validTokens).Trim();
	}	

	if (!string.IsNullOrEmpty(assemblyConfigurationLayout))
	{
		assemblyConfigurationLayout = ReplaceTokens(assemblyConfigurationLayout, validTokens).Trim();
	}

	if (!string.IsNullOrEmpty(assemblyVersionLayout) && assemblyVersionLayout != validTokens["VersionNumber"])
	{
		assemblyVersionLayout = ReplaceTokens(assemblyVersionLayout, validTokens).Trim();
	}

	if (!string.IsNullOrEmpty(assemblyFileVersionLayout) && assemblyFileVersionLayout != validTokens["VersionNumber"])
	{
		assemblyFileVersionLayout = ReplaceTokens(assemblyFileVersionLayout, validTokens).Trim();
	}

	if (!string.IsNullOrEmpty(assemblyInformationalVersionLayout) && assemblyInformationalVersionLayout != validTokens["VersionNumber"])
	{
		assemblyInformationalVersionLayout = ReplaceTokens(assemblyInformationalVersionLayout, validTokens).Trim();
	}
#>

<#+ if (Configuration == "Unspecified") { #>

<#+ } #>

<#+ if (!string.IsNullOrEmpty(assemblyCompanyLayout)) { #>
[assembly: AssemblyCompany("<#= assemblyCompanyLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyCopyrightLayout)) { #>
[assembly: AssemblyCopyright("<#= assemblyCopyrightLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyConfigurationLayout)) { #>
[assembly: AssemblyConfiguration("<#= assemblyConfigurationLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyVersionLayout)) { #>
[assembly: AssemblyVersion("<#= assemblyVersionLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyFileVersionLayout)) { #>
[assembly: AssemblyFileVersion("<#= assemblyFileVersionLayout #>")]
<#+ } #>
<#+ if (!string.IsNullOrEmpty(assemblyInformationalVersionLayout)) { #>
[assembly: AssemblyInformationalVersion("<#= assemblyInformationalVersionLayout #>")]
<#+ } #>
<#+

//TODO: find a way to include other stuff in version.props for the shared asm info
//[assembly: AssemblyTrademark("" "")]
//[assembly: CLSCompliant(true)]
//[assembly: NeutralResourcesLanguage("en")]
//[assembly: CodeLanguage("CS")]

}

private Version GetDefaultVersion(XmlNode projectRoot, XmlNode solutionRoot)
{
	var major = Int32.MinValue;
	var minor = Int32.MinValue;
	var build = Int32.MinValue;
	var revision = Int32.MinValue;

	var majorFromConvention = GetNode(projectRoot, solutionRoot, "MajorVersion/text()", false);
	int.TryParse(majorFromConvention, out major);

	var minorFromConvention = GetNode(projectRoot, solutionRoot, "MinorVersion/text()", false);
	int.TryParse(minorFromConvention, out minor);

	var buildNumberFromEnvironment = Environment.GetEnvironmentVariable("BUILD_NUMBER");
	if (!string.IsNullOrEmpty(buildNumberFromEnvironment))
	{
		if (buildNumberFromEnvironment.Contains("."))
		{
			Version buildNumberFromEnvironmentVersion = null;
			if (Version.TryParse(buildNumberFromEnvironment, out buildNumberFromEnvironmentVersion))
			{
				if (major == Int32.MinValue)
				{
					major = buildNumberFromEnvironmentVersion.Major;
				}

				if (minor == Int32.MinValue)
				{
					minor = buildNumberFromEnvironmentVersion.Minor;
				}

				if (build == Int32.MinValue)
				{
					build = buildNumberFromEnvironmentVersion.Build;
				}

				if (revision == Int32.MinValue)
				{
					revision = buildNumberFromEnvironmentVersion.Revision;
				}
			}
		}
		else
		{
			if (build == Int32.MinValue)
			{
				int.TryParse(buildNumberFromEnvironment, out build);
			}
		}
	}

	var buildNumberFromConvention = GetNode(projectRoot, solutionRoot, "BUILD_NUMBER/text()", false);
	if (!string.IsNullOrEmpty(buildNumberFromConvention))
	{
		if (buildNumberFromConvention.Contains("."))
		{
			Version buildNumberFromConventionVersion = null;

			if (Version.TryParse(buildNumberFromConvention, out buildNumberFromConventionVersion))
			{
				if (major == Int32.MinValue)
				{
					major = buildNumberFromConventionVersion.Major;
				}

				if (minor == Int32.MinValue)
				{
					minor = buildNumberFromConventionVersion.Minor;
				}

				if (build == Int32.MinValue)
				{
					build = buildNumberFromConventionVersion.Build;
				}

				if (revision == Int32.MinValue)
				{
					revision = buildNumberFromConventionVersion.Revision;
				}
			}
		}
		else
		{
			if (build == Int32.MinValue)
			{
				int.TryParse(buildNumberFromConvention, out build);
			}
		}
	}

	if (major == Int32.MinValue)
	{
		major = 1;
	}

	if (minor == Int32.MinValue)
	{
		minor = 0;
	}

	if (build == Int32.MinValue)
	{
		var epochDateTime = new DateTime(2000, 1, 1);
		build = DateTime.UtcNow.Subtract(epochDateTime).Days;
	}

	if (revision == Int32.MinValue)
	{
		revision = (int)DateTime.UtcNow.TimeOfDay.TotalSeconds;
	}

	var version = new Version(major, minor, build, revision);
	return version;
}

private string GetNode(XmlNode projectRoot, XmlNode solutionRoot, string xpath, bool @throw)
{
    if (projectRoot != null)
    {
        var projectChild = projectRoot.SelectSingleNode(xpath);
        if (projectChild != null)
        {
            return projectChild.Value;
        }
    }

    var solutionChild = solutionRoot.SelectSingleNode(xpath);
	if (solutionChild != null) { return solutionChild.Value; }

	if (!@throw) { return null; }
	var name = xpath.Replace("/text()", "");
	throw new ArgumentException(name + " must be specified in version.props", name);
}

private string ReplaceTokens(string source, Dictionary<string,string> tokens)
{
	foreach (string token in tokens.Keys)
	{
		source = source.Replace("$(" + token + ")", tokens[token]);
	}

	return source;
}

private string GetProcessOutput(string localPath, string path, string command)
{
	if (!File.Exists(path)) { return null; }

	var psi = new ProcessStartInfo(path, command)
	{
		WindowStyle = ProcessWindowStyle.Hidden,
		UseShellExecute = false,
		ErrorDialog = false,
		CreateNoWindow = false,
		WorkingDirectory = localPath,
		RedirectStandardOutput = true,
		RedirectStandardError = true
	};

	using (var p = Process.Start(psi))
	{
		p.WaitForExit();
		if (p.ExitCode != 0)
		{
			using (var standardError = p.StandardError)
			{
				//TODO: just write to stdout?
				//Host.Error(standardError.ReadToEnd());
			}
			return null;
		}

		using (var standardOutput = p.StandardOutput)
		{
			return standardOutput.ReadToEnd();
		}
	}
}

public string HgVersion(string path)
{
	path = path ?? ".";

	//Log.LogMessage(MessageImportance.Low, "path is {0}", path);
	var programFiles = string.Format(@"{0}\Program Files", drive);
	var programFilesx86 = string.Format(@"{0}\Program Files (x86)", drive);
	var hg = string.Format(@"{0}\TortoiseHg\hg.exe", programFiles);
	var hgx86 = string.Format(@"{0}\TortoiseHg\hg.exe", programFilesx86);
	var merc = string.Format(@"{0}\Mercurial\hg.exe", programFiles);
	var mercx86 = string.Format(@"{0}\Mercurial\hg.exe", programFilesx86);

	//try standard locations and fall back to assumption of it being in path
	var hgPath = File.Exists(hgx86) ? hgx86 : File.Exists(hg) ? hg :
		File.Exists(mercx86) ? mercx86 : File.Exists(merc)? merc : null;

	if (null == hgPath)
	{
		foreach (string p in Environment.GetEnvironmentVariable("PATH").Split(';'))
		{
			var test = Path.Combine(p, "hg.exe");
			if (File.Exists(test))
			{
				hgPath = test;
				break;
			}
		}
	}
	return GetProcessOutput(path, hgPath, "log -l 1 --template \"{node|short}\"");	
}

//borrowed / modified from from https://gist.github.com/966148
public string GitVersion(string path)
{
	path = path ?? ".";

	//Log.LogMessage(MessageImportance.Low, "path is {0}", path);
	var programFiles = string.Format(@"{0}\Program Files", drive);
	var programFilesx86 = string.Format(@"{0}\Program Files (x86)", drive);
	var git = string.Format(@"{0}\git\bin\git.exe", programFiles);
	var gitx86 = string.Format(@"{0}\git\bin\git.exe", programFilesx86);

	//try standard locations and fall back to assumption of it being in path
	var gitPath = File.Exists(gitx86) ? gitx86 : File.Exists(git) ? git : null;

	if (null == gitPath)
	{
		foreach (string p in Environment.GetEnvironmentVariable("PATH").Split(';'))
		{
			var test = Path.Combine(p, "git.exe");
			if (File.Exists(test))
			{
				gitPath = test;
				break;
			}
		}	
	}
	return GetProcessOutput(path, gitPath, "log -1 --pretty=format:%h");
}
#>